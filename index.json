[{"categories":["基础概念"],"content":"这篇文章主要介绍工作中常用到的环境变量，让大家能有一个清晰彻底的认识。 注意 文章内容主要是我个人的观点，如有疑问，欢迎评论区留言。 ","date":"2021-06-13","objectID":"/environment/:0:0","tags":["配置"],"title":"谈谈对环境变量的认识","uri":"/environment/"},{"categories":["基础概念"],"content":"1、环境变量是什么 环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。 变量：可以随意给其赋值的一个存储单元 环境变量，可以理解为操作系统里设置的一些全局变量，这些全局变量是为了方便操作系统的运行、调度。 ","date":"2021-06-13","objectID":"/environment/:1:0","tags":["配置"],"title":"谈谈对环境变量的认识","uri":"/environment/"},{"categories":["基础概念"],"content":"2、为什么要设置环境变量 举个常见的例子：windows系统下，假如我们安装了某一款软件，安装结束后，在安装目录会生成一个该软件的.exe文件，双击该文件，我们就能启动软件。但是难道我们每次要运行该软件的时候都要先找到该.exe文件所在的路径，然后双击吗，显然是不可能的，因为安装的软件太多，我们根本不可能记住所有已安装软件的路径，同时如果我们在其他路径下想运行某些软件岂不是完蛋了。 这时候就需要环境变量了。 ","date":"2021-06-13","objectID":"/environment/:2:0","tags":["配置"],"title":"谈谈对环境变量的认识","uri":"/environment/"},{"categories":["基础概念"],"content":"3、环境变量的作用 通过在环境变量里面加入所有软件的安装路径，当我们想运行某一软件时双击其快捷方式或者在DOS界面输入软件名称，此时，计算机除了在其当前目录下寻找该软件的.exe文件外，还在环境变量中搜索软件的路径，找到，运行。 比如，Path是一个常见的环境变量，它告诉操作系统，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下寻找此程序外，还应到哪些目录下寻找。 用户通过设置环境变量，来更好的运行进程。 ","date":"2021-06-13","objectID":"/environment/:3:0","tags":["配置"],"title":"谈谈对环境变量的认识","uri":"/environment/"},{"categories":["基础概念"],"content":"4、环境变量的分类 一、按照生命周期来分，Linux环境变量可以分为两类： 永久的：需要用户修改相关的配置文件，变量永久生效。 临时的：用户利用export命令，在当前终端下声明环境变量，关闭Shell终端失效。 二、按照作用域来分，Linux环境变量可以分为： 系统环境变量：系统环境变量对该系统中所有用户都有效。 用户环境变量：顾名思义，这种类型的环境变量只对特定的用户有效。 ","date":"2021-06-13","objectID":"/environment/:4:0","tags":["配置"],"title":"谈谈对环境变量的认识","uri":"/environment/"},{"categories":["基础概念"],"content":"5、不同文件的作用 /etc/profile： 为系统的每个用户设置环境信息和启动程序，当用户第一次登录时，该文件被执行，其配置对所有登录的用户都有效。当被修改时，必须重启才会生效。 /etc/environment： 系统的环境变量，/etc/profile是所有用户的环境变量，前者与登录用户无关，后者与登录用户有关，当同一变量在两个文件里有冲突时，以用户环境为准。 /etc/bashrc： 为每个运行 bash shell 的用户执行该文件，当 bash shell 打开时，该文件被执行，其配置对所有使用bash的用户打开的每个bash都有效。当被修改后，不用重启只需要打开一个新的 bash 即可生效。 ~/.bash_profile： 为当前用户设置专属的环境信息和启动程序，当用户登录时该文件执行一次。默认情况下，它用于设置环境变量，并执行当前用户的 .bashrc 文件。理念类似于 /etc/profile，只不过只对当前用户有效，也需要重启才能生效。 ~/.bashrc： 为当前用户设置专属的 bash 信息，当每次打开新的shell时，该文件被执行。理念类似于/etc/bashrc，只不过只对当前用户有效，不需要重启只需要打开新的shell即可生效。 ~/.bash_logout： 为当前用户，每次退出bash shell时执行该文件，可以把一些清理工作的命令放进这个文件。 注意 以上需要重启才能生效的文件，其实可以通过source xxx 暂时生效。 文件的执行顺序为：当登录Linux时，首先启动/etc/environment和/etc/profile，然后启动当前用户目录下的~/.bash_profile，执行此文件时一般会调用~/.bashrc文件，而执行~/.bashrc时一般会调用/etc/bashrc，最后退出shell时，执行~/.bash_logout。简单来说顺序为： （登录时）/etc/environment –\u003e /etc/profile(以及/etc/profile.d/里的文件) –\u003e ~/.bash_profile –\u003e （打开shell时）~/.bashrc –\u003e /etc/bashrc –\u003e （退出shell时）~/.bash_logout ","date":"2021-06-13","objectID":"/environment/:5:0","tags":["配置"],"title":"谈谈对环境变量的认识","uri":"/environment/"},{"categories":["基础概念"],"content":"6、终端的作用 终端的工作：用户通过终端输入命令，终端将命令传入计算机，执行后，并把结果输入到终端上显示。 但是现在计算机硬件一体化程度越来越高，硬件质量也越来越强，输入输出设备完全没必要单独用一个硬件和计算机进行交换信息了，取而代之使用软件终端和计算机进行交互信息。 这就是终端模拟器 (Terminal Emulator)，也就是我们现在所讨论的终端。除了它不是硬件，它符合终端的概念和工作流程。 举个例子，下面这些软件都是终端： GNU/Linux：gnome-terminal、Konsole； macOS：Terminal.app、iTerm2； Windows：Win32 控制台、ConEmu 等。 ","date":"2021-06-13","objectID":"/environment/:6:0","tags":["配置"],"title":"谈谈对环境变量的认识","uri":"/environment/"},{"categories":["基础概念"],"content":"7、shell的作用 我之前很迷惑一个问题是，有终端就够了嘛，输入命令，执行并把结果输出，要shell干什么。 所以需要明确下终端负责的工作。终端的工作范围：接收用户的输入，显示传过来的输出。（此外还提供一些优化用户体验的功能，比如支持文字复制粘贴、软件背景颜色的调整等） 终端的工作其实是很少的哦，简单来说三点：GUI软件界面、接收输入、显示输出。 而shell的核心工作就是操控计算机内核（如新建文件等等），即访问操作系统中的某个具有一定功能、可以处理具体事务的文件(二进制文件 —- 此类文件经常被称作工具)、或包含一定内容的文件(文本文件) 我们一般讨论shell都是指命令行shell。 shell为什么叫做命令解释器？ 不管是GUI shell 还是命令行 Shell，其实都是在解释命令，只不过GUI shell隐藏解释命令细节，用户通过点击鼠标的操作操作内核命令。 ","date":"2021-06-13","objectID":"/environment/:7:0","tags":["配置"],"title":"谈谈对环境变量的认识","uri":"/environment/"},{"categories":["基础概念"],"content":"8、几种常见的Shell /bin/bash /bin/csh /bin/dash /bin/ksh /bin/sh /bin/tcsh /bin/zsh bash: Bash 是最常见的 shell，Mac 中默认 shell 就是 bash。 [bash官网这篇文章]描述了唤起 bash shell 时加载的不同文件：login shell 加载 ~/.bash_profile ，而non-login shell 加载 ~/.bashrc 。 zsh: 很多人的 mac 中会使用 zsh 而不是 bash，一大半是因为 oh-my-zsh 这个配置集，它兼容 bash，还有自动补全等好用的功能。zsh 的配置文件~/.zshrc 注意 以上需要重启才能生效的文件，其实可以通过source xxx 暂时生效。 文件的执行顺序为：当登录Linux时，首先启动/etc/environment和/etc/profile，然后启动当前用户目录下的~/.bash_profile，执行此文件时一般会调用~/.bashrc文件，而执行~/.bashrc时一般会调用/etc/bashrc，最后退出shell时，执行~/.bash_logout。简单来说顺序为： mac系统使用zsh修改.bash_profile文件失效问题： 因为终端默认修改为了zsh，使用.bash_profile配置环境变量之后重启终端就会配置失效 解决方案： 在终端输入vim ~/.zshrc 配置环境变量 在最后加上这句： source ~/.bash_profile ","date":"2021-06-13","objectID":"/environment/:8:0","tags":["配置"],"title":"谈谈对环境变量的认识","uri":"/environment/"},{"categories":["基础概念"],"content":"9、常用的几个命令 使用env查看所有环境变量 env 使用echo命令查看单个环境变量。例如： echo $PATH 查看所有的shell cat /etc/shells 查看当前窗口使用的shell版本 echo $SHELL 输出当前使用的shell echo $0 我们修改系统默认shell为bash chsh -s /bin/bash ","date":"2021-06-13","objectID":"/environment/:9:0","tags":["配置"],"title":"谈谈对环境变量的认识","uri":"/environment/"},{"categories":null,"content":"老张是谁 💻 老张就是老张，一个大龄的前端程序猿，曾就职于豚厂、福报厂。 ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"关于老张","uri":"/about/"},{"categories":null,"content":"老张来自哪里 🏠 老张来自豫西南的一个小山村，当前在魔都打拼💪🏻💪🏻💪🏻💪🏻💪🏻💪🏻 ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"关于老张","uri":"/about/"},{"categories":null,"content":"如何联系老张 ☎️ 老张是一个热性的北方小伙，现在已经是大汉了。可以通过QQ(3022411758)加我，验证信息就回答：“程序猿老张”。 ","date":"2019-08-02","objectID":"/about/:3:0","tags":null,"title":"关于老张","uri":"/about/"},{"categories":["协同开发"],"content":" 代码回滚，适用于的场景： 1.提交错代码，想放弃刚刚提交的部分； 2.代码发生冲突，处理比较麻烦，为了代码安全，直接回滚到之前干净的代码。 ","date":"2019-03-02","objectID":"/sourcetree/:0:0","tags":["配置"],"title":"使用SourceTree回滚","uri":"/sourcetree/"},{"categories":["协同开发"],"content":"我个人理解，可以分为本地回滚和远程回滚： ","date":"2019-03-02","objectID":"/sourcetree/:0:1","tags":["配置"],"title":"使用SourceTree回滚","uri":"/sourcetree/"},{"categories":["协同开发"],"content":"一.本地回滚，回滚自己已经提交的代码，但还未推送到远程仓库。 目前我在本地提交了两次，但第二次有大量错误代码，我选择放弃，想直接回到第一次提交的位置，采取以下步骤： 选中你想回滚到的提交记录，右击-\u003e将（所在分支）重置到这次提交-\u003e强行合并-\u003e确定 ","date":"2019-03-02","objectID":"/sourcetree/:0:2","tags":["配置"],"title":"使用SourceTree回滚","uri":"/sourcetree/"},{"categories":["协同开发"],"content":"二.远程回滚，即回滚远程代码仓库的代码。 SourceTree默认是不提供这种操作的，因为存在风险。所以，回滚远程代码，一定要注意： 1.想要放弃的代码，是所有开发成员都一致同意的； 2.想要放弃的代码只是自己的，中间没有别人的提交记录，这可以直接回滚。 3.这个操作过程中，提醒其他成员不要推送代码。 操作步骤如下： 1.SourceTree开启允许强制推送权限 2.和本地回滚一样，先回滚到想要的位置 3.强制推送代码，切记这个时候不要拉取代码 5.完成操作，本地和远程的代码都是你想要回滚的地方。 ","date":"2019-03-02","objectID":"/sourcetree/:0:3","tags":["配置"],"title":"使用SourceTree回滚","uri":"/sourcetree/"}]